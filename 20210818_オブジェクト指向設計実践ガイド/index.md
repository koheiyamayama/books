# 1章 オブジェクト指向設計
- 変化があるから、ソフトウェアには設計が必要である。設計とは変化に対して柔軟に対応できるようにするものである。
- CA的に言うと、ソフトウェアは変更容易性があるのが特徴であり、価値である。それを達成するためにはオブジェクト指向を活かしていくことが大切である。
- オブジェクト間のメッセージの受け渡しが依存関係を生む。オブジェクト指向設計とはこの依存関係を管理することである。
- 設計の目的は「変更コストの削減」である。

# 2章 単一責任のクラスを設計する
- 変更が簡単であるとは
  - 変更は副作用をもたらさない
  - 要件の変更が小さければ、コードの変更も相応して小さい
  - 既存のコードは簡単に再利用できる
  - 最も簡単な変更方法はコードの追加である。ただし追加するコードはそれ自体変更が容易なものとする。
- 上を実現する上で、コードには以下のような性質を持つはず。
  - 見通しが良い(Transparent) 変更がもたらす影響が明白である
  - 合理的(Reasonable) どんな変更であっても、掛かるコストは変更がもたらす利益にふさわしい
  - 利用性が高い(Usable) 新しい環境、予期していなかった環境でも再利用できる
  - 模範的(Exemplary) コードに変更を加える人が上記の品質を自然と保つようなコードになっている
- 頭文字を取ってTRUEなコードと呼ばれる。
- CleanArchitectureに書いてあることを読むのが大事そう。
- クラスに1つの責任を持たせること
- 1つの責任を持たせるには変更理由が1つになるようにすること

# 3章 依存関係を管理する
- 1つのオブジェクトだけでアプリケーションを作っていくのは大抵の場合できない。規模によるだろうけど。
- 複数のオブジェクトでアプリケーションを作り、それらの相互作用によってアプリケーションが構築されるわけだが、この相互作用によってオブジェクト間の結合を生み出す。これらを慎重に管理する必要がある。
- 依存関係があるオブジェクトの特徴は、片方のオブジェクトに変更を加えた時にもう一方のオブジェクトにも変更をしなければならない場合である。具体的な特徴は以下4つ。
  - 他のクラスの名前
  - self以外のどこかに送ろうとするメッセージの名前
  - メッセージが要求する引数
  - それら引数の順番
- 疎結合なコードを書くための手法
  - 依存オブジェクトの注入
    - 以下のコードはGearクラスがWheelオブジェクトとしか協力しないことを示している。が、本来であれば直径を計算できるオブジェクトと協力できるはずである。
    ```crystal
    class Gear
      def gear_inches
        Wheel.new(rim, tire).diameter
      end
    end
    ```  
    なので、以下のように直すことができる。
    ```crystal
    def gear_inches
      ratio * wheel.diameter
    end
    ```
    このような手法を「Dependency Injection」と呼ぶ。
  - 脆い外部メッセージを隔離する
  ```crystal
  def gear_inches
    ratio * wheel.diameter
  end
  ```
  ↑はwheelオブジェクトがdiameterに応答することを、Gearオブジェクトは知っているということになります。
  この依存関係を別のメソッドに隔離します。
  ```crystal
  def gear_inches
    ratio * wheel.diameter
  end

  private def diameter
    wheel.diameter
  end
  ```
  - インスタンスを作成するときの引数の順番を管理する。
  色々な方法が載っているが、1つを紹介する。
  これはinitializeメソッドの引数を自分自身で変更できない場合に取れる手法の1つである。
  ```crystal
  module GearWrapper
    def self.gear(args)
      # Gearクラスが外部ライブラリで提供されるものと仮定する。
      Gear.new(args[:chainring], args[:cog], args[:wheel])
    end
  end

  GearWrapper.gear({chainring: 40, cog: 20, wheel: Wheel.new(10, 10)})
  # => Gearオブジェクトを返す
  ```
  こうすることで外部クラスのGearの引数の順番に依存せずに、自分自身でGearオブジェクトを生成するときの、引数の扱い決めることができる。
  これをファクトリーと呼ぶ。ファクトリーは、クラスの唯一の目的が他のクラスのインスタンスの作成であるクラスのことである。
  - 依存方向の管理
    - 依存関係には方向がある。方向を選択する際には「変わりにくいクラスに依存せよ」が大事。具体的に言うと以下。
      - あるクラスは、他のクラスよりも要件が変わりやすい
      - 具象クラスは、抽象クラスよりも変わる可能性が高い
      - 多くのところから依存されたクラスを変更すると、広範囲に影響が及ぶ

# 4章 柔軟なインターフェイスを作る
- オブジェクト指向設計はクラスだけでなく、オブジェクト間のメッセージもすごい大事である。つまり、以下3つが大事である。で、メッセージはオブジェクトのインターフェイスを通して送受信される。
  - オブジェクトの責任
  - オブジェクトの依存関係
  - オブジェクトのインターフェイス
- クラスのパブリックインターフェイスは以下の特性を備えている。
  - クラスの主要な責任を明らかにする
  - 外部から実行されることが想定される
  - 気まぐれに変更されない
  - 他社がそこに依存しても安全
  - テストで完全に文書化されている
- クラスのプライベートインターフェイスは以下の特性を備えている。
  - 実装の詳細に関わる
  - 他のオブジェクトから送られてくることは想定していない
  - どんな理由でも変更され得る
  - 他者がそこに依存するのは危険
  - テストでは言及されない場合がある
- シーケンス図を使う
  - シーケンス図を使ってオブジェクト、クラス間で使われるメッセージを明らかにしていく。このメッセージがオブジェクトのパブリックインターフェイスになりうる。
  - あるオブジェクトは別のオブジェクトにこのメッセージを飛ばすのか？また、受けてはこのメッセージを受け取るべきなのか？などをシーケンス図で明らかにできる。
- メッセージの内容は「どのように」ではなく、「何を」であるべき。
  - 以下のユースケースを想定する。
    - 旅行が開始されるためには、使われる自転車が全て整備されていることを確実にする必要がある。
    - これをシーケンス図で表すと、以下のようになりうる。
    ```plantuml
    @startuml 4.5
    Trip -> Mechanic: clean_bicycle(bike)
    Trip <-- Mechanic
    Trip -> Mechanic: pump_tires(bike)
    Trip <-- Mechanic
    Trip -> Mechanic: lube_chain(bike)
    Trip <-- Mechanic
    Trip -> Mechanic: check_brakes(bike)
    Trip <-- Mechanic            
    @enduml
    ```
    このシーケンス図は「どのように」を多く含んだパブリックインターフェイスとなっている。なぜならTripは「全ての自転車の整備」に関するインターフェイスがMechanicに定義されていることを知っている。これだと自転車の整備に「整備道具の確認」というものができた場合、Tripはそれを知らなければならなくなる。つまり、Mechanicオブジェクトの変更がTripオブジェクトに影響を与えてしまう。
    なので、「どのように」から「何を」へパブリックインターフェイスを変えていくと、↓みたいなシーケンス図ができる。
    ```plantuml
    @startuml 4.6
    Trip -> Trip: bicycles
    note over Trip: for each bicycle
    Trip -> Mechanic: prepare_bicycle(bike)
    Trip <-- Mechanic
    @enduml
    ```
- コンテキストの独立を模索する
  - 4.6のシーケンス図では、TripはMechanicがprepare_bicycle(bike)に応答すると知っている。Tripを再利用するためにはMechanicオブジェクトも持ち続ける必要がある。こういうのをコンテキストと呼ぶ。
  - 具体的に4.6のシーケンス図では、「旅行で必要な自転車一台一台を整備士が準備する」という風になっている。これは「旅行で必要な自転車を準備するか？」と読むことができ、どのように準備するのか？というのが多分に含まれている。これよりも「旅行で必要な自転車を準備する」というメッセージを整備士に投げられる方がどのようにを排除できる。
  - コンテキストがあることでオブジェクトの再利用性が下がる。これを脱するためにDependency Injectionを使う。
  具体的にシーケンス図を書いて、4.6を改良する。
  ```plantuml
  @startuml 4.7
  Trip -> Mechanic: prepare_trip(self)
  Trip <-- Mechanic: bicycles
  note over Mechanic: for each bicycle
  Trip --> Mechanic: prepare_bicycle(bike)
  Trip <-- Mechanic
  @enduml
  ```
  4.7のシーケンス図を見ると、
  - prepare_tripというパブリックインターフェイスがMechanicに生えており、これを呼び出すと、整備士が持つ「旅行を準備する」責任を満たすようになっている。
- 他のオブジェクトを信頼する
  -  4.5、4.6、4.7を日本語でそれぞれ表すと、以下になる。
    - 4.5: 私は何を望んでいるか知っているし、あなたがどのように何をするのかも知っている
    - 4.6: 私は何を望んでいるか知っているし、あなたが何をするのか知っている
    - 4.7: 私は何を望んでいるか知っているし、あなたがそれをやってくれると信じている
  - 上記の変遷を辿るほど、オブジェクト指向設計っぽくなる。
- インターフェイスを作る経験則
  - 明示的なインターフェイスを作る
    - 明示的にパブリックインターフェイスだと特定できる
    - 「どのように」よりも「何を」になっている
    - 名前は考えられる限り変わり得ない
    - オプション引数としてハッシュを取る
- デメテルの法則
  - オブジェクトを疎結合にするためのコーディング規則の集まり
  - デメテルは3つ目のオブジェクトにメッセージを送る際に、異なる型の2つ目のオブジェクトを介することを禁じます。具体的にいうと、以下みたいなコード。
  ```crystal
  customer.bicycle.wheel.tire
  customer.bicycle.wheel.rotate
  ```
  - 上のコードはこれが定義されるオブジェクトに多くの依存がある、要するにコンテキストを要求する。なので、このコードがあるオブジェクトの再利用性はとても低くなる。
  - 二行目のコードを考えると、rotateが変更されると、オブジェクトに影響を及ぼす。これはオブジェクトから遠いところで起きているので、見通しが悪い。
  - デメテルの法則に対する違反を回避するためには、delegateやラッパーメソッドを使う。
  - delegateは他のオブジェクトにメッセージを渡すことである。
  - デメテルに違反している場合、パブリックインターフェイスが必要なのでは？というヒントになる。

# 5章 ダックタイピングでコストを削減する
- CleanArchitectureのポリモーフィズムは動的言語だとダックタイピングで実現される。
- ダックタイピングとは、ダックタイプはいかなる特定のクラスとも結びつかないパブリックインターフェイスである。クラスをまたぐインターフェイスはアプリケーションに大きな柔軟性をもたらす。これはクラスへの依存がメッセージへの寛容な依存で置き換えられうことになる。要するにインターフェイスに依存するっていうこと。
- ダックタイピングを上手く使うことでいい感じのコードを書けるが、難しいのはどうやってダックタイピングを使う場所を見つけるか。
- 次のコードはダックタイピングを使うべき場所である可能性がある。
  - クラスで分岐するcase文
  - kind_of?とis_a?
  - responds_to?

# 6章 継承によって振る舞いを獲得する
- 継承とはメッセージの自動委譲の仕組みである。オブジェクトがメッセージに応えられない時に他のオブジェクトにメッセージを転送する、その転送経路を定義するものである。

# 7章 モジュールでロールの振る舞いを共有する
- 

# 8章 コンポジションでオブジェクトを組み合わせる
- コンポジションとは組み合わされた全体が単なる部品の集合以上となるように、個別の部品を複雑な全体へと組み合わせる行為である。

